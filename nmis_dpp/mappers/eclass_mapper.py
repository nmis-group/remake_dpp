"""
eclass_mapper.py

Implementation of SchemaMapper for ECLASS 16.
"""

from typing import Dict, Any, List, Tuple
import logging

from nmis_dpp.schema_base import SchemaMapper
from nmis_dpp.model import (
    IdentityLayer,
    StructureLayer,
    LifecycleLayer,
    RiskLayer,
    SustainabilityLayer,
    ProvenanceLayer,
)
from nmis_dpp.part_class import PartClass

logger = logging.getLogger(__name__)

class ECLASSMapper(SchemaMapper):
    """
    Mapper for ECLASS 16.0.
    """

    def get_schema_name(self) -> str:
        return "ECLASS"

    def get_schema_version(self) -> str:
        return "16.0"

    def get_context(self) -> Dict[str, Any]:
        """
        Return JSON-LD context for ECLASS.
        Simple placeholder for now, usually would point to ECLASS RDF/OWL.
        """
        return {
            "eclass": "https://eclass.eu/eclass-standard/v16-0/",
            "ird": "https://eclass.eu/ird/",
        }

    def map_identity_layer(self, layer: IdentityLayer) -> Dict[str, Any]:
        """
        Map identity layer. ECLASS has specific properties for manufacturer ID, etc.
        For now, we map generic keys to ECLASS-like keys.
        """
        return {
            "manufacturerId": layer.ownership.get("manufacturer"),
            "manufacturerPartId": layer.global_ids.get("manufacturer_pn"),
            "serialNumber": layer.global_ids.get("serial"),
            "gtin": layer.global_ids.get("gtin"),
        }

    def map_structure_layer(self, layer: StructureLayer) -> Dict[str, Any]:
        """
        Map structure layer. The most important part is the 'parts' list,
        which we map using map_part_class.
        """
        mapped_parts = [self.map_part_class(p) for p in layer.parts]
        return {
            "hierarchy": layer.hierarchy, # Pass-through structure for now
            "components": mapped_parts,
        }

    def map_lifecycle_layer(self, layer: LifecycleLayer) -> Dict[str, Any]:
        return {
            "manufactureDate": layer.manufacture.get("date"),
            "batchId": layer.manufacture.get("lot"),
        }

    def map_risk_layer(self, layer: RiskLayer) -> Dict[str, Any]:
        return {} # Placeholder

    def map_sustainability_layer(self, layer: SustainabilityLayer) -> Dict[str, Any]:
        return {
            # "carbonFootprint": ..., # removed as it belongs to lifecycle layer
            "mass": layer.mass,
        }

    def map_provenance_layer(self, layer: ProvenanceLayer) -> Dict[str, Any]:
        return {} # Placeholder

    def map_part_class(self, part: PartClass) -> Dict[str, Any]:
        """
        Map a PartClass instance to an ECLASS representation.
        If the part has an explicit ECLASS binding, use it.
        Otherwise, look up the PartClass type in the loaded config
        (generated by eclass_build_mapping.py).
        """
        binding = part.get_binding("ECLASS")
        
        eclass_classification = None
        if binding and binding.class_ids:
             eclass_classification = binding.class_ids[0] # Take the first one
        
        # If no explicit binding, check config mapping
        if not eclass_classification:
            domain_mappings = self.config.get("domain_mappings", {})
            domain_map = domain_mappings.get(part.type)
            if domain_map:
                # Use the 'eclass_classes' from config if available (keys are IRDIs)
                # This is a simplification; we might just want to list *possible* classes
                classes = domain_map.get("eclass_classes", {})
                if classes:
                    eclass_classification = list(classes.keys())[0] # Pick the first available class for this domain

        return {
            "id": part.part_id,
            "name": part.name,
            "eclassIrdi": eclass_classification,
            "attributes": part.properties,
        }

    def validate_mapping(self, mapped_data: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """
        Basic validation.
        """
        errors = []
        if not mapped_data.get("schema") == "ECLASS":
             errors.append("Schema mismatch")
        return len(errors) == 0, errors
